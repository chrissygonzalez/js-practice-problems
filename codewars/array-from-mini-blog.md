# Array.from()
I've used `Array.from()` in the past when I wanted to use Array methods on Array-like collections (like those generated by `document.getElementsByClass`, for example). I didn't think much more about it until I tried a problem called Tower Builder on Code Wars and saw it used in one of the top solutions:

```javascript
function towerBuilder(n) {
     return Array.from({length: n}, function(v, k) {
       const spaces = ' '.repeat(n - k - 1);
       return spaces + '*'.repeat(k + k + 1) + spaces;
     });
   }
```

Of the ideas I had considered for my own solution, none involved `Array.from()`, so I decided to investigate. I read the MDN documentation for `Array.from()` and saw that it can also take an optional map function. This explained the purpose of the second parameter in the solution, but what's going on with the first? Ah, MDN describes array-like objects as 'objects with a length property and indexed elements'. So if you just try `Array.from()` on the first parameter, you get an array of the specified length with each value set to `undefined`.

```javascript
Array.from({length: 5});
// returns [undefined, undefined, undefined, undefined, undefined]
```

Now that I have an array of the length I need, is it possible to do it again, but with actual values? The solution's map function uses `k` and `v` as parameters, which makes me think there are keys and values...in an array? (Not that I know of.) A bit of `console.log()` later, I discovered that the second parameter counts up with each map iteration. But why?

```javascript
Array.from({length: 5}, (k, v) => v);
// returnsÂ [0, 1, 2, 3, 4]
```

A quick review of `Array.prototype.map()` reveals that `map()`'s second and third optional parameters are the value and the index, so perhaps a slightly clearer set of variable names might instead be: 

```javascript
Array.from({length: 5}, (currentValue, index) => index);
// returnsÂ [0, 1, 2, 3, 4]
```